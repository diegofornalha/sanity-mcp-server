/**
 * Type consistency testing utilities
 *
 * This file provides utilities for testing type compatibility between tools
 * and controllers. These functions ensure that the parameter shapes used in
 * tool definitions match those expected by the controllers.
 */
import {z, ZodType} from 'zod'

import type {ToolDefinition} from '../../../src/types/tools.js'

/**
 * Converts a Zod schema to a plain object representation for testing purposes
 *
 * @param schema Zod schema to convert
 * @returns Plain object representation of the schema
 */
export function zodSchemaToObject<T>(schema: ZodType<T>): T {
  try {
    // We're using safe.parse here which doesn't throw
    // but returns a result object with success/error
    return mockZodValue(schema) as T
  } catch (error) {
    console.error('Error creating object from schema:', error)
    throw error
  }
}

/**
 * Creates a mock object based on a Zod schema
 *
 * @param schema Zod schema to create a mock from
 * @returns Mock object that satisfies the schema
 */
export function mockObjectFromSchema<T>(schema: ZodType<T>): T {
  try {
    // Test the schema with a mock value
    const mockValue = mockZodValue(schema)

    // Special case for mutations array which is required in many schemas
    if (typeof mockValue === 'object' && mockValue !== null && !('mutations' in mockValue)) {
      if (schema instanceof z.ZodObject) {
        const shape = schema.shape as Record<string, ZodType<any>>
        if ('mutations' in shape) {
          (mockValue as any).mutations = []
        }
      }
    }

    // Try validating, but don't throw if it fails - just return the mock value
    try {
      schema.parse(mockValue)
    } catch (error) {
      if (error instanceof z.ZodError) {
        console.error('Schema validation error:', error.message)
      }
    }

    return mockValue as T
  } catch (error) {
    console.error('Error creating mock object from schema:', error)
    return {} as T
  }
}

/**
 * Creates a mock value for a specific Zod type
 *
 * @param schema Zod type to create a mock value for
 * @returns Mock value that satisfies the schema
 */
function mockZodValue(schema: ZodType<any>): any {
  // Special handling for different schema types
  if (schema instanceof z.ZodString) {
    return 'test-string'
  } else if (schema instanceof z.ZodNumber) {
    return 42
  } else if (schema instanceof z.ZodBoolean) {
    return true
  } else if (schema instanceof z.ZodArray) {
    // Create an array with a single mock item
    return [mockZodValue(schema.element)]
  } else if (schema instanceof z.ZodObject) {
    const shape = schema.shape as Record<string, ZodType<any>>
    const result: Record<string, any> = {}

    for (const [key, fieldSchema] of Object.entries(shape)) {
      result[key] = mockZodValue(fieldSchema)
    }

    // Special handling for document objects
    if (
      result._type === undefined &&
      (schema.description?.includes('document') || Object.keys(result).includes('_id'))
    ) {
      result._type = 'test-type'
    }

    return result
  } else if (schema instanceof z.ZodRecord) {
    // Create a record with one test key
    const value: Record<string, any> = {testKey: mockZodValue(schema.valueSchema)}

    // If this appears to be a document, add a _type field
    if (schema.description?.includes('document')) {
      value._type = 'test-type'
    }

    return value
  } else if (schema instanceof z.ZodEnum) {
    // Return the first enum value
    const values = schema._def.values
    return values[0]
  } else if (schema instanceof z.ZodUnion) {
    // Return a mock value for the first option
    return mockZodValue(schema._def.options[0])
  } else if (schema instanceof z.ZodOptional || schema instanceof z.ZodNullable) {
    // Return a mock value for the wrapped schema
    return mockZodValue(schema.unwrap())
  } else if (schema instanceof z.ZodDefault) {
    // Return the default value if available, otherwise mock the inner schema
    try {
      return schema._def.defaultValue()
    } catch {
      return mockZodValue(schema._def.innerType)
    }
  } else {
    // Fallback for other schema types
    return {}
  }
}

/**
 * Tests if a tool definition's parameter schema is compatible with its handler function
 *
 * @param toolDef Tool definition to test
 * @returns True if the parameter schema is compatible with the handler function
 */
export function testToolParameterConsistency(toolDef: ToolDefinition): boolean {
  try {
    // Check that the parameter schema is defined
    if (!toolDef.parameters) {
      console.error(`Tool ${toolDef.name} has no parameter schema`)
      return false
    }

    // Create and validate a mock object from the parameter schema
    mockObjectFromSchema(toolDef.parameters)

    // Check that the handler exists
    if (!toolDef.handler) {
      console.error(`Tool ${toolDef.name} has no handler function`)
      return false
    }

    return true
  } catch (error) {
    console.error(`Error in testToolParameterConsistency for ${toolDef.name}:`, error)
    return false
  }
}

/**
 * Tests if a controller function's parameters match the tool definition's schema
 *
 * @param controllerFn Controller function to test
 * @param toolDef Tool definition that uses the controller
 * @returns True if the controller function's parameters are compatible with the tool definition's schema
 */
export function testControllerToolConsistency(
  _controllerFn: unknown,
  toolDef: ToolDefinition
): boolean {
  try {
    // Ensure parameter schema is valid
    const isValid = testToolParameterConsistency(toolDef)

    if (!isValid) {
      console.error(`Tool ${toolDef.name} has inconsistent parameter types`)
    }

    return isValid
  } catch (error) {
    console.error(`Error in testControllerToolConsistency for ${toolDef.name}:`, error)
    return false
  }
}

/**
 * Tests if the result type of a controller function matches the expected result type of a tool
 *
 * @param controllerFn Controller function to test
 * @param toolDef Tool definition that uses the controller
 * @returns True if the controller function's result type is compatible with the tool's expected result type
 */
export function testResultTypeConsistency(
  _controllerFn: unknown,
  toolDef: ToolDefinition
): boolean {
  try {
    // For now just validate that the tool has a coherent parameter schema
    const isValid = testToolParameterConsistency(toolDef)

    if (!isValid) {
      console.error(`Tool ${toolDef.name} has inconsistent result types`)
    }

    return isValid
  } catch (error) {
    console.error(`Error in testResultTypeConsistency for ${toolDef.name}:`, error)
    return false
  }
}

/**
 * Tests if a tool's parameter schema correctly handles optional parameters
 *
 * @param toolDef Tool definition to test
 * @returns True if the tool correctly handles optional parameters
 */
export function testOptionalParameterHandling(toolDef: ToolDefinition): boolean {
  try {
    // Create a mock object from the parameter schema with only required fields
    const requiredOnly = createRequiredOnlyMock(toolDef.parameters)

    // Try to validate the object with the schema
    const result = toolDef.parameters.safeParse(requiredOnly)

    return result.success
  } catch (error) {
    console.error(`Optional parameter handling error in tool ${toolDef.name}:`, error)
    return false
  }
}

/**
 * Creates a mock object with only the required fields from a Zod schema
 *
 * @param schema Zod schema to extract required fields from
 * @returns Object with only the required fields
 */
function createRequiredOnlyMock<T>(schema: ZodType<T>): Partial<T> {
  if (schema instanceof z.ZodObject) {
    const shape = schema.shape as Record<string, ZodType<any>>
    const result: Record<string, any> = {}

    for (const [key, fieldSchema] of Object.entries(shape)) {
      // Only include non-optional fields
      if (!(fieldSchema instanceof z.ZodOptional)) {
        result[key] = mockZodValue(fieldSchema)
      }
    }

    return result as Partial<T>
  }

  return {} as Partial<T>
}
